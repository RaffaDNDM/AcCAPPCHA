\chapter{Experimental results}
All the tests were performed on a MSI GL63 8RD laptop, using Windows 10 Home version 1909 as Operating System.

\section{Human detection}
The application response was tested over all the three possible scenarios (see \myref{Section}{AcCAPPCHA:user_activity}): 
\begin{itemize}
\item{Time correspondence}
\item{Character correspondence}
\item{Both time and character correspondence}
\end{itemize}
The first method is the most efficient and usually at first or second trial already finds a human activity. Sometimes the correspondence isn't found at first trial because of background noise. \\
The last two approaches based on deep learning require the reduction of the number of labels to obtain good results. In this way I limit the possible characters that user could use and the password should be composed of lower case alphabetic characters, accented vowels or numbers (see \myref{Figure}{Results:keyboard}) but considering again the 10 high probable labels predicted for each peak.\\
In any case the last method that uses both the time and the character correspondence speed up the search of the correct peak related to the insertion and reduces the possibility of having a false positive. However there are many false negatives given by the similar sound produces by several keys opposite to D. Asonov, R. Agrawal's conclusions\cite{keyboard_acoustic}.\\
The reasons of their presence could be:
\begin{itemize}
\item{different parts of my keyboard plate produce similar sounds}
\item{the built-in microphone of my laptop is more affected by the noise than an external microphone}
\item{the movements of the user's hands influence the noise during the password insertion}
%WORN OUT = usurato
\item{some keys are more worn out that other}
The worst deep learning method is the one that uses the spectrograms and a pre-trained deep learning model to extract the features of a press peak. In \myref{Table}{}
However during the insertion of the password, the user can obviously type backslash key but then '$\setminus b$' character isn't considered in the final verification.\\

\end{itemize}
\begin{figure}[h]
     \centering
	 \includegraphics[width=0.8\textwidth]{Images/Results/keyboard_less}
     \caption{\footnotesize{Keys to be used in the password (highlighted in green).}}\label{Results:keyboard}
\end{figure}
\begin{table}[h]
\centering
\begin{tabular}{ccc}
\hline
{\textbf{Feature type}}&{\textit{bye5}}&{\textit{hello35}}\\
\hline
\multirow{3}{*}{FFT of touch peak} & {2 (3/4)} & {1}\\
& {2 (3)} & {1}\\
& {1} & {1}\\
\hline
\multirow{3}{*}{FFT of touch and hit peaks} & {2 (3)/4} & {2 (6/7)}\\
& {2 (3/4)} & {1}\\
& {3 (3/4)} & {3 (5.5/7)}\\
\hline
\multirow{3}{*}{Spectrogram of touch and hit peaks} & {NO (3)} & {NO (5.33/7)}\\
& {NO (2.67/4)} & {NO (6/7)}\\
& {NO (2.67/4)} & {NO (4.67/7)}\\
\hline
\end{tabular}
\end{table}

\section{Bot detection}
I've tested both human and bot activities analysing the response generated by AcCAPPCHA. The bot activity was emulated using several approaches and using the username \texttt{'RaffaDNDM'} and its password \textbf{'hello35'}:
\begin{itemize}
\item{\textbf{Python program with} \texttt{popen} \textbf{communication}\\
this approach opens a subprocess and a communication through pipes with stdin and stdout streams (see ). Assuming the hacker obtained the credentials in some way, the bot communicates the username and the password to running AcCAPPCHA with only time correspondence option selected. In practice the strength of AcCAPPCHA against this attack is very high because the insertion of the password is managed through \texttt{getwch()} call in the Windows Operating system. \\
This function belongs to \texttt{msvcrt} module and takes one character at the time. This module guarantees also that the console I/O routines are not compatible with stream I/O or low-level I/O library routines. In the Windows operating systems, the output from these functions is always directed to the console and cannot be redirected through any king of pipes.\\
The program easily accepts the username, because AcCAPPCHA acquires it using standard \texttt{input()} function. Then AcCAPPCHA waits for characters of password, until ENTER key is pressed, but popen doesn't have access to the stream analysed by \texttt{getwch()}. I didn't iterate the insertion of the password for the maximum number of possible trials because even at the first insertion, AcCAPPCHA doesn't see the insertion of the bot.
\begin{lstlisting}[language=python, showstringspaces=false, tabsize=4, basicstyle=\footnotesize, caption={\footnotesize{Bot using popen.}},label={Results:popen_bot}]
from subprocess import Popen
import sys
import msvcrt
from time import sleep

def popen_bot(username, password):
    #Subprocess that redirects pipes
    process = Popen('python3 AcCAPPCHA.py -t -plot',
    				shell=True, 
    				stdin=subprocess.PIPE,
    				stdout=subprocess.PIPE,
    				stderr=subprocess.STDOUT)

    #Wait until username could be inserted
    sleep(4)
    #Write username and password
    credentials = username.encode() + b'\r\n' + \
    			  password.encode() + b'\r\n'
    output = process.communicate(credentials)[0]
    
    print(output.decode())
\end{lstlisting}
}
\item{\textbf{Python program with} \texttt{pynput} \textbf{module}\\
Using this module, I pretended to be a bot and access directly the console, bypassing the stream limits of \textbf{msvcrt} character acquisition. To emulate the user the bot program should start the execution run and immediately after the hacker must open the working terminal with AcCAPPCHA running.\\
This scenario isn't very feasible because requires management of terminal windows but was useful to establish if the insertion of the password by malicious software is correctly classified as a bot activity. Each character of the password is inserted emulating press and release of the corresponding key of the keyboard.
\begin{lstlisting}[language=python, showstringspaces=false, tabsize=4, basicstyle=\footnotesize, caption={\footnotesize{Bot using pynput module.}},label={Results:pynput_bot}]
from pynput.keyboard import Key, Controller
from time import sleep

def input_bot(username, password):
    #Object for control of keyboard events
    keyboard = Controller()

    def press_release(char):
        keyboard.press(char)
        keyboard.release(char)

    #Wait that username could be inserted
    sleep(4)

    #username insertion
    for x in username:
        press_release(x)
    
    press_release(Key.enter)

    #Trials for password insertion
    count = 0
    while(count<3):
        sleep(5)
        
        for x in password:
            press_release(x)

        press_release(Key.enter)
        count += 1
\end{lstlisting}
}
\item{\textbf{Remote control of the PC}\\
the last test was performed by using the program \texttt{Team Viewer} and accessing directly the terminal. For this reason, this type of attack isn't feasible in practice as the previous mentioned attack with Python bot.}
\end{itemize}
In the last two approaches the audio recorded by AcCAPPCHA are very similar and highlights the two most probable situations:
\begin{itemize}
\descItem{The noise during noise evaluation is very high}{If this happens, no audio peaks can be found (see \myref{Figure}{Results:silence_img}).}
\descItem{The noise during noise evaluation is normal or very low}{If this happens, some audio peaks can be found if there is some noise during password insertion. However they don't have time correspondence with time instants stored during the password insertion (see \myref{Figure}{Results:noise_img}). The only case, in which a bot can authenticate it self, is when there is a sequence of audio peaks caused by the noise and the time between them is the same of the stored ones. However this event isn't very probable because it is hard that there would be too high noise only during the insertion of the password and not during the noise evaluation. For example, if the attacker would analyse the background noise finding a sequence of peaks and defining a model for amount of time between each couple of them, he couldn't use information from it. In fact it could insert a character of the password after an amount time previously modelled but in practice, the peaks of background noise would be discarded through noise evaluation.}
\end{itemize}
\begin{figure}[h]
     \centering
	 \begin{subfigure}[b]{0.48\textwidth}
         \centering
         \includegraphics[width=\linewidth]{Images/Results/Bot/silence}
         \caption{\footnotesize{Bot with \texttt{pynput} module.}}
     \end{subfigure}
	 \hfill     
     \begin{subfigure}[b]{0.48\textwidth}
         \centering
         \includegraphics[width=\linewidth]{Images/Results/TeamViewer/silence}
         \caption{\footnotesize{Team Viewer.}}
     \end{subfigure}
     \caption{\footnotesize{Plot of audio during the password insertion with high noise during noise evaluation.}}\label{Results:silence_img}
\end{figure}
\begin{figure}[h]
     \centering
	 \begin{subfigure}[b]{0.48\textwidth}
         \centering
         \includegraphics[width=\linewidth]{Images/Results/Bot/noise}
         \caption{\footnotesize{Bot with \texttt{pynput} module.}}
     \end{subfigure}
	 \hfill     
     \begin{subfigure}[b]{0.48\textwidth}
         \centering
         \includegraphics[width=\linewidth]{Images/Results/TeamViewer/noise}
         \caption{\footnotesize{Team Viewer.}}
     \end{subfigure}
     \caption{\footnotesize{Plot of audio during the password insertion with low noise during noise evaluation.}}\label{Results:noise_img}
\end{figure}

\section{Security analysis}
