\chapter{Invisible CAPPCHA}\label{chapter:InvisibleCAPPCHA}
The \textit{Invisible CAPPCHA} is an evolution of CAPPCHA, in terms of usability\cite{Invisible_CAPPCHA}. The main difference with respect to CAPPCHA is that the challenge isn't explicitly submitted to user but it's hidden behind the PIN authentication phase. This type of challenge works only on smartphones as its ancestor.\\
This CAPTCHA is a method developed in 2018 and based on motion side-channel information, obtained by sensors on mobile device. The main steps that this CAPTCHA follows are:
\begin{enumerate}
\item{Motion detection}
\item{Communication between Client and Server}
\end{enumerate}
In fact, the micro-movements of the device, generated by the interaction of the user with the touch-screen, are evaluated by the \textit{Secure Element} (\textit{SE}). Then credentials are shared with the remote Service Provider if the input is inserted by a human or not. The Invisible CAPPCHA is very effective as support of Password-based authentication methods.

\section{Motion detection}
The accelerometer of the device detects the acceleration over the three axis in g-force units, as a sequence of vectors over time:
$$\{ A_i\}_{i=1}^{n} = \{ (a_1^x, a_1^y, a_1^z), ..., (a_n^x, a_n^y, a_n^z)\}$$
This type of side-channel information from embedded accelerometer has been exploited in different attacks for the single and double tap detection. These attacks analyse the acceleration over the z-axis over by comparing them to thresholds and timing conditions.\\
In Invisible CAPPCHA, the side-channel information is stored on the memory of the mobile device. Depending on the device, a smartphone built-in vibration can be generated only along Z axis or along more than one axis (Figure \ref{inv:vibration}). Instead the finger tap event creates accelerations similar and higher on Z-axis (Figure \ref{inv:tap}).\\
In Invisible CAPPCHA, the difference between built-in vibration and tap acceleration is evaluated by a simple algorithm. This algorithm relies on negative and positive peaks which are detected by comparing acceleration along Z axis against predefined thresholds. The userâ€™s tap cannot be simulated by malware using the vibration motors.\\
The most important requirement is that Invisible CAPPCHA uses a Secure Element that embedded the accelerometer, blocking the access to the sensor by malicious code. Nowadays there exists a smart card, called SIMSense, that already integrates motion sensor.\\
\begin{figure}[h]
     \centering
     \includegraphics[width=.8\linewidth]{Images/InvisibleCAPPCHA/vibration}
     \caption{\footnotesize{Example of accelerations caused by smartphone built-in vibration.}}\label{inv:vibration}
\end{figure}
\begin{figure}[h]
     \centering
     \includegraphics[width=.8\linewidth]{Images/InvisibleCAPPCHA/tap}
     \caption{\footnotesize{Example of accelerations caused by finger tap detection.}}\label{inv:tap}
\end{figure}


\section{Communication between Client and Server}\label{inv:communication}
When the user fills a form or provides other information to a cloud application/service, the Secure Element checks if a micro-movement is measured when a user tap is detect. If this happens the input inserted by user is considered valid, generated by a human, otherwise the algorithm tells that the input was generated by a malware.\\
An extra message, that tells if the task was performed by a user or not, is sent to the server side. The integrity of this message is guaranteed by the Secure Element, that can be equipped with a digital signature. The identity of the device can be associated to the sent message and then it can be checked and verified. The Secure Element signs the verification message through ECDSA.\\

\subsection{Elliptic Curve Digital Signature Algorithm (ECDSA)}
This type of encryption works similarly to RSA but it's based on elliptic cryptography and uses keys of smaller sizes. The algorithm is divided in two phases:
\begin{itemize}
\descItem{Sign generation}
{If Alice wants to send a message, protected with digital sign, to Bob, they need to share the following parameters \textit{(curve, G, n)}. \textit{curve} is the equation of the curve, \textit{G} base point of prime order on the curve and \textit{n} is the multiplicative order of \textit{G} for which $n\; x\; G = O$.\\
Alice generates a private key $d_A$ in the range $[1, n-1]$ and a public key $Q_A=d_A\; x\; G$, where $x$ is scalar multiplication of a point of the curve. Alice needs to perform Algorithm \ref{inv:ECDSA_sign} to sign a message.
\begin{algorithm}[h]
\DontPrintSemicolon
\KwIn {$\mathtt{m}$= message to be signed}
\KwOut {$\mathtt{(r,s)}$= digital sign}
\BlankLine
$e\gets HASH(m)\;$where \textit{HASH} is an hash function (e.g. SHA-2)\;
\BlankLine
$z \gets$ string composed by the $L_n$ most left bits\;
$\;\;\;\;\;\;\;$where $L_n$ is the bit length of the group of order $n$\;
$r\gets 0$\;
$s\gets 0$\;
\BlankLine
\While{$r=0\;mod\;n$ or $r=0\;mod\;n$}{
	\BlankLine
	$k\gets RANDOM([1,n-1])$\;
	\BlankLine
	$(x_1, y_1)=k\;x\;G$ of the elliptic curve\;
	\BlankLine
	$r\gets x_1\; mod\; n$\;
	\BlankLine
	{$s\gets k^{-1}(z+rd_{A})\; mod\; n$}
	\BlankLine
}
\caption{Sign generation.}\label{inv:ECDSA_sign}
\end{algorithm}
}
\descItem{Sign verification}
{Bob wants to verify the digital signature sent by Alice. To do it, he needs to perform in order Algorithm \ref{inv:ECDSA_key_verify} and \ref{inv:ECDSA_verify}.
\begin{algorithm}[h]
\DontPrintSemicolon
\KwIn {$\mathtt{Q_A}$= public key to be verified}
\KwOut {$\mathtt{check}$= true if public key is correct}
\BlankLine
$\mathtt{check}\gets true$\;
\BlankLine
$\setminus\setminus$Valid coordinates\;
\If{$Q_A=O$}
{	
$\mathtt{check}\gets false$\;
}
\BlankLine
$\setminus\setminus$Element of the curve\;
\If{$Q_A\;\in$ curve}
{	
$\mathtt{check}\gets false$\;
}
\BlankLine
$\setminus\setminus$Correctness of order\;
\If{not $n\;x\;Q_A=O$}
{	
$\mathtt{check}\gets false$\;
}
\caption{Verification that public key is on the elliptic curve.}\label{inv:ECDSA_key_verify}
\end{algorithm}

\begin{algorithm}[h]
\DontPrintSemicolon
\KwIn {$\mathtt{(r,s,m)}$= digital sign and message}
\KwOut {$\mathtt{m}$= message to be signed}
\BlankLine
$e\gets HASH(m)\;$where \textit{HASH} is an hash function (e.g. SHA-2)\;
\BlankLine
$z \gets$ string composed by the $L_n$ most left bits\;
where $L_n$ is the bit length of the group of order $n$\;
\BlankLine
\If{not $r\;\in [1, n-1]$ or not $s\;\in [1, n-1]$}
{*Invalid sign*}
$e\gets HASH(m)\;$\;
\BlankLine$z \gets$ string composed by the $L_n$ most left bits\;
$w=s^{-1}\; mod\; n$\;
\BlankLine
$u_1 =zw\; mod\; n$\;
$u_2 =rw\; mod\; n$\;
$(x_1, y_1)=u_1\; x\; G\;+\; u_2\; x\; Q_{A}$ of the elliptic curve\;
\BlankLine
\If{$r\equiv x_1\; (mod\; n)$}
{*Verified sign*}
\Else{*Not accepted sign*}
\BlankLine
\caption{Sign verification.}\label{inv:ECDSA_verify}
\end{algorithm}
}
\end{itemize}
In Invisible CAPPCHA the message \textit{m} is bitwise concatenated with a signed unique value, nonce \textit{n}, so the signed message sent to the server is \textit{(r, s, m, n)} and not \textit{(r, s, m)}.

\section{Security analysis}
After the sign of the verification, the communication must be also encrypted to ensure integrity and authenticity of exchanged messages.\\
The Secure Element can be accessed only through PIN authentication of the off-card communication party. If the malicious code has enough privileges to access Secure Element, it can't brute force the password because of limited number of permitted attempts. If the number of attempts is higher than the maximum one, the attacker is performing a Denial Of Service (DOS) attack. The attacker can also try to steal the password through side-channel information.\\

\subsection{Strength against popular attacks}
The most popular attacks, that have been analysed, are\cite{Invisible_CAPPCHA}:
\begin{itemize}
\descItem{Replay attack}
{Because the message is signed together with a nonce, an attacker can't easily use a message already sent by a client to the server. In fact, the server checks if a nonce was already used by the client and if so, the server refuse the message of the attacker.
}
\descItem{Reverse engineering attack}
{Even if the attacker can de-obfuscate the code of the application running on the browser, he can access to reserved data on the server only if the verification message for human interaction was correctly signed by the Secure Element. Hence this type of attack can't be performed.}
\descItem{Human-solver relay attack}
{The Invisible CAPPCHA is strong to this type of attack because it doesn't require any additional task to be sent to a remote human solver, as in standard CAPTCHAs.}
\descItem{Brute force and password replay attacks}
{Invisible CAPPCHA can be used to validate every input before it considers it as a possible attempt for a password. If the password was inserted by a malware or was wrong, the number of attempts decreases. Hence this approach prevents a brute force attack. This also prevents the access to the Secure Element by the attacker in replay attacks.
}
\descItem{Denial Of Service (DOS)}
{If a malware tries more than the maximum amount of attempts of passwords can do a Denial Of Service (DOS) of the Secure Element. To prevent this attack, the Secure Element can block access to itself if three invalid passwords inserted by a human. If an invalid password is inserted by a malware, detected by Invisible CAPPCHA, the Secure Element is blocked.}
\end{itemize}